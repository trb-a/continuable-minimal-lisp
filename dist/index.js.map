{"version":3,"sources":["core.json","interpreter.ts","index.ts"],"names":["module","exports"],"mappings":"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","file":"index.js","sourceRoot":"..\\src","sourcesContent":["module.exports=[\"do\",[\"def\",\"new\",[\"fn\",[\"a\",\"&\",\"b\"],[\".\",\"Reflect\",[\"`\",\"construct\"],\"a\",\"b\"]]],[\"def\",\"del\",[\"fn\",[\"a\",\"b\"],[\".\",\"Reflect\",[\"`\",\"deleteProperty\"],\"a\",\"b\"]]],[\"def\",\"list\",[\"fn\",[\"&\",\"a\"],\"a\"]],[\"def\",\">=\",[\"fn\",[\"a\",\"b\"],[\"if\",[\"<\",\"a\",\"b\"],!1,!0]]],[\"def\",\">\",[\"fn\",[\"a\",\"b\"],[\"if\",[\">=\",\"a\",\"b\"],[\"if\",[\"=\",\"a\",\"b\"],!1,!0],!1]]],[\"def\",\"<=\",[\"fn\",[\"a\",\"b\"],[\"if\",[\">\",\"a\",\"b\"],!1,!0]]],[\"def\",\"classOf\",[\"fn\",[\"a\"],[\".\",[\".-\",[\".-\",\"Object\",[\"`\",\"prototype\"]],[\"`\",\"toString\"]],[\"`\",\"call\"],\"a\"]]],[\"def\",\"not\",[\"fn\",[\"a\"],[\"if\",\"a\",!1,!0]]],[\"def\",\"null?\",[\"fn\",[\"a\"],[\"=\",null,\"a\"]]],[\"def\",\"true?\",[\"fn\",[\"a\"],[\"=\",!0,\"a\"]]],[\"def\",\"false?\",[\"fn\",[\"a\"],[\"=\",!1,\"a\"]]],[\"def\",\"string?\",[\"fn\",[\"a\"],[\"if\",[\"=\",\"a\",null],!1,[\"=\",[\"`\",\"String\"],[\".-\",[\".-\",\"a\",[\"`\",\"constructor\"]],[\"`\",\"name\"]]]]]],[\"def\",\"pr-str\",[\"fn\",[\"&\",\"a\"],[\".\",[\"map\",[\".-\",\"JSON\",[\"`\",\"stringify\"]],\"a\"],[\"`\",\"join\"],[\"`\",\" \"]]]],[\"def\",\"str\",[\"fn\",[\"&\",\"a\"],[\".\",[\"map\",[\"fn\",[\"x\"],[\"if\",[\"string?\",\"x\"],\"x\",[\".\",\"JSON\",[\"`\",\"stringify\"],\"x\"]]],\"a\"],[\"`\",\"join\"],[\"`\",\"\"]]]],[\"def\",\"prn\",[\"fn\",[\"&\",\"a\"],[\"do\",[\".\",\"console\",[\"`\",\"log\"],[\".\",[\"map\",[\".-\",\"JSON\",[\"`\",\"stringify\"]],\"a\"],[\"`\",\"join\"],[\"`\",\" \"]]],null]]],[\"def\",\"println\",[\"fn\",[\"&\",\"a\"],[\"do\",[\".\",\"console\",[\"`\",\"log\"],[\".\",[\"map\",[\"fn\",[\"x\"],[\"if\",[\"string?\",\"x\"],\"x\",[\".\",\"JSON\",[\"`\",\"stringify\"],\"x\"]]],\"a\"],[\"`\",\"join\"],[\"`\",\" \"]]],null]]],[\"def\",\"list?\",[\"fn\",[\"a\"],[\".\",\"Array\",[\"`\",\"isArray\"],\"a\"]]],[\"def\",\"contains?\",[\"fn\",[\"a\",\"b\"],[\".\",\"a\",[\"`\",\"hasOwnProperty\"],\"b\"]]],[\"def\",\"get\",[\"fn\",[\"a\",\"b\"],[\"if\",[\"contains?\",\"a\",\"b\"],[\".-\",\"a\",\"b\"],null]]],[\"def\",\"set\",[\"fn\",[\"a\",\"b\",\"c\"],[\"do\",[\".-\",\"a\",\"b\",\"c\"],\"a\"]]],[\"def\",\"keys\",[\"fn\",[\"a\"],[\".\",\"Object\",[\"`\",\"keys\"],\"a\"]]],[\"def\",\"vals\",[\"fn\",[\"a\"],[\".\",\"Object\",[\"`\",\"values\"],\"a\"]]],[\"def\",\"cons\",[\"fn\",[\"a\",\"b\"],[\".\",[\"`\",[]],[\"`\",\"concat\"],[\"list\",\"a\"],\"b\"]]],[\"def\",\"concat\",[\"fn\",[\"&\",\"a\"],[\".\",[\".-\",[\"list\"],[\"`\",\"concat\"]],[\"`\",\"apply\"],[\"list\"],\"a\"]]],[\"def\",\"nth\",\"get\"],[\"def\",\"first\",[\"fn\",[\"a\"],[\"if\",[\">\",[\".-\",\"a\",[\"`\",\"length\"]],0],[\"nth\",\"a\",0],null]]],[\"def\",\"last\",[\"fn\",[\"a\"],[\"nth\",\"a\",[\"-\",[\".-\",\"a\",[\"`\",\"length\"]],1]]]],[\"def\",\"count\",[\"fn\",[\"a\"],[\".-\",\"a\",[\"`\",\"length\"]]]],[\"def\",\"empty?\",[\"fn\",[\"a\"],[\"if\",[\"list?\",\"a\"],[\"=\",0,[\".-\",\"a\",[\"`\",\"length\"]]],[\"=\",\"a\",null]]]],[\"def\",\"slice\",[\"fn\",[\"a\",\"b\",\"&\",\"end\"],[\".\",\"a\",[\"`\",\"slice\"],\"b\",[\"if\",[\">\",[\".-\",\"end\",[\"`\",\"length\"]],0],[\"get\",\"end\",0],[\".-\",\"a\",[\"`\",\"length\"]]]]]],[\"def\",\"rest\",[\"fn\",[\"a\"],[\"slice\",\"a\",1]]],[\"def\",\"and\",[\"~\",[\"fn\",[\"&\",\"xs\"],[\"if\",[\"empty?\",\"xs\"],!0,[\"if\",[\"=\",1,[\".-\",\"xs\",[\"`\",\"length\"]]],[\"first\",\"xs\"],[\"list\",[\"`\",\"let\"],[\"list\",[\"`\",\"__and\"],[\"first\",\"xs\"]],[\"list\",[\"`\",\"if\"],[\"`\",\"__and\"],[\"concat\",[\"`\",[\"and\"]],[\"rest\",\"xs\"]],[\"`\",\"__and\"]]]]]]]],[\"def\",\"or\",[\"~\",[\"fn\",[\"&\",\"xs\"],[\"if\",[\"empty?\",\"xs\"],null,[\"if\",[\"=\",1,[\".-\",\"xs\",[\"`\",\"length\"]]],[\"first\",\"xs\"],[\"list\",[\"`\",\"let\"],[\"list\",[\"`\",\"__or\"],[\"first\",\"xs\"]],[\"list\",[\"`\",\"if\"],[\"`\",\"__or\"],[\"`\",\"__or\"],[\"concat\",[\"`\",[\"or\"]],[\"rest\",\"xs\"]]]]]]]]],null];","/* eslint-disable no-loop-func */\n/* eslint-disable no-throw-literal */\n\n// -------------------------------------------------------\n//                       Consant\n// -------------------------------------------------------\nexport const LANGUAGE = \"Continuable-miniMAL-Lisp\";\nexport const VERSION = \"0.4.0\";\n\n// -------------------------------------------------------\n//                   Type definitions\n// -------------------------------------------------------\n\n// Expr accepts almost evrything. Defined just to avoid using `any'.\nexport type Expr = Expr[] | bigint | boolean | JSFunction | number\n  | object | string | symbol | undefined | null;\n\nexport type Env = [Record<string, Expr>, Env | null]; // [bound symbols, upper env]\n\n// Base object acts like parent of root environment, but not referenced by\n// Env object.\ntype Base = { [x: string]: any };\n\n// Base object reference (BOR) referes any property in the Base which\n// can be accessed by string instead of having refered object itself\n// to keep environment and AST serializable as far as possible.\n// BOR is created when you refer your environment to get something\n// from the Base, and dereferenced when you use it ( passing it to\n// JS functions, accessing property, etc )\nexport type BOR = { bor: string };\n\n// Applicables.\nexport type Lambda = [\"=>\", string[], Exclude<Expr, JSFunction> | JSLambdaFunction, Env]; // JS Labmda or Lisp labmda\n\nexport type Macro = [\"~\", Applicable];\n\ntype JSFunction = (...args: any[]) => any;\n\nexport type Continuation = {\n  current: Eval,\n  stack: EvalStack,\n  info?: Expr, // Can set a information whatever.\n  lang: string,\n  version: string,\n};\ntype Applicable = Lambda | JSFunction | Continuation | Macro;\n\n// Evaluation stack.\nexport type Eval = { parent: Expr[], index: number, env: Env, flag: string | null, dynamicEnv: Env, handler: Eval | null };\nexport type EvalStack = Eval[];\n\n// Interpreter options.\nexport type Options = {\n  stackMax?: number, // Stack size. Throw error when exceed this.\n  base?: Base, // Upper of root environment.\n  env?: Env, // Environment root (except base).\n  loadCore?: boolean, // Load core on construct or not.\n  debugMode?: boolean, // Show debug messsage using console.log if true.(except loading core)\n  debugCore?: boolean, // Show debug message when loading core.\n  debugMax?: number, // Throw error if debugCount exceeds this.\n  debugFilter?: (message: string) => boolean, // Filter debug message, before checking debugMax.\n};\n\n// Function to handle a form.\ntype FormHandler = (args: {\n  node: Readonly<Expr[]>,\n  env: Env,\n  dynamicEnv: Env,\n  base: Base,\n  flag: string | null,\n  handler: Eval | null,\n  cont: Continuation,\n  interpreter: Interpreter,\n}) => {\n  ret: Expr,\n  subevals?: (Partial<Eval> | null | undefined | false)[], // falsy values will be eliminaed.\n  reevals?: Partial<Eval>[],\n};\n\n// Fn form. Export this because they might define functions out of interpreter.\nexport type JSLambdaFunction = (env: EnvWrapper, itrp: Interpreter) => Expr;\nexport type Fn = [\"fn\", string[], Exclude<Expr, JSFunction> | JSLambdaFunction];\n\n// Others.\ntype Try = [\"try\", Expr, [any, \"string\", Expr]];\ntype Let = [\"let\", Expr[], Expr];\ntype DynamicLet = [\"dynamic-let\", Expr[], Expr];\n\n// -------------------------------------------------------\n//                   Utilities\n// -------------------------------------------------------\n\n// Creates a deep clone of given AST recursively.\n// Arrays and simple objects are cloned. Instances of classes are not.\nexport const cloneAST = (ast: any, map = new Map<any, any>()): Expr => {\n  if (map.has(ast)) {\n    return map.get(ast);\n  } else if (typeof ast === \"object\" && ast !== null && ast.constructor === Object) {\n    return Object.keys(ast).reduce((acc, key) => {\n      acc[key] = cloneAST(ast[key], map);\n      return acc;\n    }, {} as any);\n  } else if (ast instanceof Array) {\n    const arr = map.set(ast, []).get(ast)! as Expr[];\n    arr.push(...ast.map((a: Expr) => cloneAST(a, map)));\n    return arr;\n  } else {\n    return ast;\n  }\n};\n\n// Throws string.\n// Note: Javascript's stacktrace is meaningless for lisp errors.\n// IMPROVEME: implement lisp stacktrace.\nconst error = (str: string): never => {\n  throw str;\n}\n\n// Delete all the keys with undefined value in a object.\nconst deleteUndefined = (obj: any): void => {\n  if (typeof obj === \"object\" && obj !== null) {\n    Object.keys(obj).filter(k => obj[k] === undefined).forEach(k => delete obj[k]);\n  }\n}\n\n// const isPromise = <T, S>(obj: PromiseLike<T> | S): obj is PromiseLike<T> =>\n//   !!obj && (typeof obj === \"object\" || typeof obj === \"function\") &&\n//   typeof (obj as any).then === \"function\";\n\n// -------------------------------------------------------\n//               Type guards / asserts\n// -------------------------------------------------------\n\n// Asserts x is string. Use this before setEnv or findEnv.\nconst assertSymbol: (x: any) => asserts x is string = (x) =>\n  (typeof x === \"string\") || error(`${x} is not a symbol`);\n\n// Asserts x is string or number or symbol.\nconst assertPropertyIndex: (x: any) => asserts x is \"string\" | \"number\" | \"symbol\" = (x) => (\n  typeof x === \"string\" || typeof x === \"symbol\" ||\n  typeof x === \"number\" || error(\"String(x) is not a property index\")\n);\n\n// Asserts x is BOR.\n// Strict check so that we don't take user's object as BOR as far as possible.\n// Note: We recommend to use Map instead of object for dictionary, if serializer accept Map.\nexport const isBOR = (base: Base, x: any): x is BOR =>\n  typeof x === \"object\" && x !== null && typeof x[\"bor\"] === \"string\" &&\n  x.constructor === Object && Object.keys(x).length === 1 && x[\"bor\"] in base;\n\n// Determines if x is AST[].\nconst isList = (x: any): x is Expr[] => (x instanceof Array);\n\n// Asserts x is AST[].\nconst assertList: (x: any) => asserts x is Expr[] = (x) =>\n  isList(x) || error(`${x} is not an array`);\n\n// Determines if x is Env.\n// Note: we don't get deep into parents, that's heavy & too much.\nexport const isEnv = (x: any): x is Env =>\n  x instanceof Array &&\n  typeof x[0] === \"object\" && x[0] !== null &&\n  (x[1] instanceof Array || x[1] === null); // can be !x[1] || isEnv(x[1])\n\n// Determines if x is a lambda ( Lisp labmda or JS lambda)\nexport const isLambda = (x: any): x is Lambda =>\n  x instanceof Array && x[0] === \"=>\" && x.length === 4 && isEnv(x[3]) && (\n    (x[1] instanceof Array && x[1].every(a => typeof a === \"string\"))\n  );\n\nexport const isMacro = (x: any): x is Macro =>\n  x instanceof Array && x[0] === \"~\" && x.length === 2\n  && isApplicable(x[1]);\n\n// Determines if x is a JSFunction\nconst isJSFunction = (x: any): x is JSFunction =>\n  typeof x === \"function\";\n\n// Determines if x is a lambda, js function or continuation.\nexport const isApplicable = (x: any): x is Applicable =>\n  isLambda(x) || isJSFunction(x) || isContinuation(x) || isMacro(x);\n\n// Asserts if x is a lambda, js function or continuation.\nconst assertApplicable: (x: any) => asserts x is Applicable = (x) =>\n  isApplicable(x) || error(`${x} is not a applicable`);\n\nconst assertMacro: (x: any) => asserts x is Macro = (x) =>\n  isMacro(x) || error(`${x} is not a macro`);\n\n// const assertJSFunction: (x: any) => asserts x is JSFunction = (x) =>\n//   typeof x === \"function\" || error(`${x} is not a JS function`);\n\n// Determines if x is evaluation request.\nconst isEval = (x: any): x is Eval =>\n  typeof x === \"object\" && x !== null &&\n  x[\"parent\"] instanceof Array &&\n  typeof x[\"index\"] === \"number\" &&\n  isEnv(x[\"env\"]) &&\n  (x[\"flag\"] === null || typeof x[\"flag\"] === \"string\") &&\n  typeof x[\"handler\"] === \"object\" // Note: null | object. We don't get in deep.\n\n// Determines if x is continuation (suspended runtime state)\n// Note: Not cheking everything, but just surface.\n// Checks format version at the same time.\nexport const isContinuation = (x: any): x is Continuation =>\n  typeof x === \"object\" && x !== null &&\n  isEval(x[\"current\"]) &&\n  x[\"stack\"] instanceof Array &&\n  typeof x[\"version\"] === \"string\" &&\n  x[\"version\"].replace(/\\.[^.]+$/, \"\") === VERSION.replace(/\\.[^.]+$/, \"\");\n\n// Asserts if x is continuation (suspended runtime state)\nconst assertContinuation: (x: any) => asserts x is Continuation = (x) =>\n  isContinuation(x) || error(`${x} is not a continuation`);;\n\n// Assert x is \"fn\" form\nconst assertFn: (x: any) => asserts x is Fn = (x) => (\n  x instanceof Array && x[0] === \"fn\" && x.length === 3 &&\n  x[1] instanceof Array && x[1].every(a => typeof a === \"string\")\n) || error(`${x} is not a fn form or malformed`);\n\n// Assert x is \"try\" form\nconst assertTry: (x: any) => asserts x is Try = (x) => (\n  x instanceof Array && x[0] === \"try\" &&\n  x[2] instanceof Array && typeof x[2][1] === \"string\" && x[2].length >= 3\n) || error(`${x} is not a try form or malformed`);\n\n// Assert x is \"let\" form\nconst assertLet: (x: any) => asserts x is Let = (x) => (\n  x instanceof Array && x[0] === \"let\" &&\n  x[1] instanceof Array && x.length >= 3\n) || error(`${x} is not a let form or malformed`);\n\n// Assert x is \"dynamic-let\" form\nconst assertDynamicLet: (x: any) => asserts x is DynamicLet = (x) => (\n  x instanceof Array && x[0] === \"dynamic-let\" &&\n  x[1] instanceof Array && x.length >= 3\n) || error(`${x} is not a let form or malformed`);\n\n// -------------------------------------------------------\n//  Create, set data to, and get data from the environment.\n// -------------------------------------------------------\n\n// Return new Env with symbols in ast bound to\n// corresponding values. \"variadic\" option allows\n// clojure style variadic parameters.\nexport const newEnv = (upper: Env, symbols: string[], values: Expr[], variadic = true): Env => {\n  const bounds: Record<string, Expr> = {};\n  for (let i = 0; i < symbols.length; i++) {\n    if (variadic && symbols[i] === \"&\") {\n      bounds[`${symbols[i + 1]}`] = values.slice(i);\n      break;\n    } else {\n      bounds[`${symbols[i]}`] = values[i];\n    }\n  }\n  return [bounds, upper];\n};\n\n// bind a value with a symbol in the environment.\nexport const setEnv = <T extends Expr>(env: Env, symbol: string, value: T): T =>\n  (env[0][`${symbol}`] = value);\n\n\n// get value and whether existance of the symbol from environment or Base.\n// returns: [<found value or null>, <found or not>, <BOR or not>]\nexport const findEnv = (env: Env, base: Base | null, symbol: string): [Expr, boolean, boolean] => {\n  for (let e: Env | null = env; !!e; e = e[1]) {\n    if (e[0].hasOwnProperty(symbol)) {\n      return [e[0][symbol], true, false];\n    } else if (\n      !e[1] && base && symbol in base && base[symbol] !== null &&\n      (typeof base[symbol] === \"object\" || typeof base[symbol] === \"function\")\n    ) {\n      const bor: BOR = { bor: symbol }; // Create BOR here.\n      return [bor, true, true];\n    }\n  }\n  return [null, false, false];\n};\n\n// Get root of env (except base)\nconst getEnvRoot = (e: Env): Env => e[1] ? getEnvRoot(e[1]) : e;\n\n// -------------------------------------------------------\n//               Interpreter class\n// -------------------------------------------------------\n\nexport class Interpreter {\n  private stackMax: number = Infinity; // Stack size. Throws error when exceeds.\n  /* eslint-disable-next-line no-use-before-define */\n  private base: Base = DEFAULT_BASE; // upper of root environment.\n  private env: Env = [{}, null]; // environment root (except base).\n  private dynamicEnv: Env = [{}, null]; // dynamic environment root\n  private loadCore: boolean = true; // load core on construct or not.\n\n  // for debugging\n  public debugCount: number = 0; // Counts how may times debug message shown.\n  public debugMode: boolean = false; // Show debug messsage if true.except loading core.\n  public debugCore: boolean = false; // Show debug messsage if true on loading core.\n  public debugMax: number = Infinity; // Throws error if debugCount exceeds this.\n  public debugFilter: (message: string) => boolean = () => true;\n\n  // Constructor can take options.\n  // Load core.json to the Base object unless disabled.\n  constructor(options?: Options) {\n    deleteUndefined(options); // Don't give any undefined value to the options.\n    Object.assign(this, options);\n    if (this.loadCore) {\n      const debugMode = this.debugMode;\n      this.debugMode = this.debugCore;\n      this.evalInBase(require(\"./core.json\"));\n      this.debugMode = debugMode;\n    }\n  }\n\n  // Show debug message on console.\n  private debug = (message: string, ...args: any[]) => {\n    if (!this.debugMode || !this.debugFilter(message)) {\n      return;\n    }\n    args = args.map(a => a instanceof Array ? cloneAST(a) : a);\n    console.log(message, ...args);\n    this.debugCount++;\n    if (this.debugCount > this.debugMax) {\n      throw new Error(\"too many debug message!\");\n    }\n  }\n\n  // Evaluates the given AST and retuns the result.\n  private evalAST = (ast: Expr, env = this.env, dynamicEnv = this.dynamicEnv): Expr | Promise<Expr> => {\n\n    // Root container contains the given AST.\n    // This enables replacement of the value even for scalar value.\n    const root = [ast];\n\n    // Evaluation stack contains evaluation requests with environment.\n    // The initial value includes the root container above.\n    const stack: EvalStack = [{ parent: root, index: 0, env, dynamicEnv, flag: null, handler: null }];\n\n    // A utility function the push evaluation requests on the stack.\n    // The evaluation will be done in the given order.\n    // Throws an exception if the given items + stacked items exceeds QUEUE_MAX.\n    const pushEvalStack = (ev: Eval): Eval => (stack.length >= this.stackMax)\n      ? error(\"Stack overflow\") : (stack.push(ev), ev);\n\n    // Continue evaluation until the stack becomes empty.\n    while (stack.length) {\n      this.debug(\"Current eval-stack length, eval-stack: \", stack.length, stack);\n      const current = stack.pop()!;\n      const { parent, index, env, dynamicEnv, flag, handler } = current;\n      const node: Expr = parent[index];\n      this.debug(\"Next evaluating AST node, env, dynamicEnv, flag: \", node, env, dynamicEnv, flag);\n\n      try {\n        if (typeof node === \"string\") {\n          // Symbol - Look up it from the environment.\n          const [v, found] = findEnv(env, this.base, node);\n          parent[index] = found ? v : error(`${node} not found`);\n\n        } else if (isList(node)) {\n          // Form - Apply it.\n\n          // Select form handler.\n          // If the car is symbol, get the value from the environment\n          // to determine if this is a macro form or coninuation form.\n          const envv = (typeof node[0] === \"string\") ? this.derefBOR(findEnv(env, this.base, node[0])[0]) : null;\n          const formHandler = isMacro(envv) ? (\n            MacroHandler\n          ) : (typeof node[0] === \"string\" && SpecialFormHandlers.hasOwnProperty(node[0])) ? (\n            SpecialFormHandlers[node[0]]\n          ) : (isContinuation(node[0]) || isContinuation(envv)) ? (\n            ContinuationFormHandler\n          ) : StandardFormHandler;\n\n          // Apply the selected form handler.\n          const { ret, subevals, reevals } = formHandler({\n            node, env, base: this.base, dynamicEnv, flag, handler,\n            cont: { current, stack, lang: LANGUAGE, version: VERSION },\n            interpreter: this,\n          });\n\n          // Push on evaluattion stack and substitute the AST according to the return values.\n          reevals?.reverse().forEach(ev => pushEvalStack({\n            parent: ev.parent ?? parent,\n            index: ev.index ?? index,\n            env: ev.env ?? env,\n            dynamicEnv: ev.dynamicEnv ?? dynamicEnv,\n            flag: ev.flag ?? null,\n            handler: ev.handler ?? handler\n          }));\n          subevals?.reverse().forEach(ev => ev && pushEvalStack({\n            parent: ev.parent ?? parent,\n            index: ev.index ?? index,\n            env: ev.env ?? env,\n            dynamicEnv: ev.dynamicEnv ?? dynamicEnv,\n            flag: ev.flag ?? null,\n            handler: ev.handler ?? handler\n          }));\n          parent[index] = ret;\n\n        } else {\n          // Not a symbol or form - Evaluated as is. Don't change the AST.\n        }\n      } catch (e) {\n        if (isContinuation(e)) {\n          // Thrown continuation does not be caught by try-catch.\n          this.debug(\"Suspend. Continuation: \", e);\n          throw e;\n        } else {\n          // Exception.\n          this.debug(\"Caught an exception. Exception: \", e);\n          if (handler) {\n            // Set the exception to the catch clause's environment.\n            const tryNode = handler.parent[handler.index];\n            assertTry(tryNode);\n            const [, , [, param]] = tryNode;\n            setEnv(handler.env, param, e);\n            // Remove evaluation requests in try-clause, which have this error handler.\n            stack.splice(0, stack.length, ...stack.filter(ev => ev.handler !== handler));\n            // Request to evaluate catch-clause.\n            pushEvalStack(handler);\n          } else {\n            // No error handler.\n            throw e;\n          }\n        }\n      } finally {\n        this.debug(\"Evaluation Done. Node, env, dynamicEnv: \", parent[index], env, dynamicEnv);\n      }\n    }\n\n    // Return the evaluated value in the container at last.\n    this.debug(\"Evaluatin finished. Result: \", root[0]);\n    return root[0];\n  }\n\n  // Evaluate AST ( as public method )\n  public eval = (ast: Expr) => {\n    return this.evalAST(ast);\n  }\n\n  // Evaluate JSON & result as JSON using JSON.parse & JSON.stringify.\n  // JSON.parse/stringify may throw exception.\n  // If JSON.stringify trows an circular/cyclic structure error, returns undefined\n  // instead of throwing exception.\n  public rep = (input: string) => {\n    try {\n      return JSON.stringify(this.eval(JSON.parse(input)));\n    } catch (e) {\n      if (e instanceof TypeError && e.message.match(/(circular|cyclic)/i)) {\n        return undefined; // returns undefined if the value contains functions anyway.\n      }\n      throw e;\n    }\n  }\n\n  // Resume with a continuation and parameter.\n  // Note: parameter can be null.\n  public resume = (cont: Continuation, value: Expr) => {\n    return this.evalAST([\"resume\", cont, value]);\n  }\n\n  // Evaluate AST with Base environment.\n  // Base environment will not be included in continuation data.\n  // Used for loading core.json.\n  public evalInBase = (ast: Expr) => {\n    this.evalAST(ast, [this.base, null]);\n  }\n\n  // Dereference if the given argument is a BOR.\n  public derefBOR = (ast: Expr) => isBOR(this.base, ast) ? this.base[ast.bor] : ast;\n\n  // Wrap given lambda with JS function.\n  // Internally used when calling JS function.\n  public wrapLambda = (ast: readonly Expr[]) => isLambda(ast)\n    ? (...a: Expr[]) => this.evalAST([[\"`\", ast], ...a])\n    : ast;\n}\n\n// -------------------------------------------------------\n//                Form handlers\n// -------------------------------------------------------\n\n// Standard form\nconst StandardFormHandler: FormHandler = ({ node, env, dynamicEnv, base, flag, interpreter }) => {\n  const f = interpreter.derefBOR(node[0]);\n  if (!flag && !isApplicable(f)) {\n    const cn = [...node];\n    return {\n      ret: cn,\n      reevals: [{ flag: \"!\" }],\n      subevals: cn.map((v, index) => ({ parent: cn, index, env })),\n    };\n  } else {\n    const [, ...args] = node;\n    // Apply function.\n    if (isJSFunction(f)) {\n      try {\n        return { ret: f(...args.map(a => interpreter.wrapLambda(interpreter.derefBOR(a)))) };\n      } catch (e) {\n        if (isContinuation(e)) {\n          throw \"Javascript function can not throw any continuation.\"\n        }\n        throw e;\n      }\n    } else if (isLambda(f)) {\n      const [, params, body, e] = f;\n      if (typeof body === \"function\") {\n        // JS lambda.\n        // Note: Unlike JS functions, JS lambda receive arguments via environemnt.\n        try {\n          const jsLambdaFunc = body as JSLambdaFunction;\n          return { ret: jsLambdaFunc(new EnvWrapper(newEnv(e!, params, args), dynamicEnv, base), interpreter) };\n        } catch (e) {\n          if (isContinuation(e)) {\n            throw \"Javascript function can not throw any continuation.\"\n          }\n          throw e;\n        }\n      } else {\n        // Lisp lambda. create a new environment with arguments mapped to parameters\n        // then evaluate the body.\n        return { ret: body, reevals: [{ env: newEnv(e!, params!, args)}] };\n      }\n    } else {\n      throw `${String(f)} is not applicable`;\n    }\n  }\n}\n\n// Macro form\n// Note: Differences macros and non-special functions are\n//   1. Macros don't evaluate the arguments.\n//   2. Macros request re-evaluation of the results.\n//   3. Macros can be applied by symbols.\n//   4. (Undocumented feature): can wrap special functions like fn/def/etc\nconst MacroHandler: FormHandler = ({ node, env, base, interpreter }) => {\n  assertSymbol(node[0]);\n  const v = interpreter.derefBOR(findEnv(env, base, node[0])[0]);\n  assertMacro(v);\n  // Apply the applicable and re-evaluate after that ( = 2 reevals )\n  return { ret: [v[1], ...node.slice(1)], reevals: [{ flag: \"!\" }, { flag: null }] };\n}\n\n// Continuation form\nconst ContinuationFormHandler: FormHandler = ({ node, flag, cont }) => {\n  const [f] = node;\n  if (!flag && !isApplicable(f)) {\n    // Evaluate the argument. (In the current environment, Not in the continuation's one)\n    const cn = [...node];\n    return {\n      ret: cn,\n      reevals: [{ flag: \"!\" }],\n      subevals: cn.map((v, index) => ({ parent: cn, index })),\n    };\n  } else {\n    // Mount the continuation on the current AST, stack, and handlers.\n    const [, ...args] = node;\n    assertContinuation(f);\n    // Pass the given argument to the suspender.\n    const { parent: cparent, index: cindex } = f.current;\n    cparent[cindex] = args[0] ?? null;\n    // replace the continuation's root with current parent.\n    // Note: we beleave the root have only 1 element in it.\n    const croot = (f.stack.length > 0) ? f.stack[0].parent : cparent;\n    if (croot.length !== 1) {\n      throw \"Illeal root of continuation\";\n    }\n    const cstack = f.stack.map(item => {\n      if (item.parent === croot) {\n        item.parent = cont.current.parent;\n        item.index = cont.current.index;\n      }\n      return item;\n    });\n    return { ret: croot[0], subevals: cstack.reverse() };\n  }\n}\n\nconst SpecialFormHandlers: Record<string, FormHandler> = {\n\n  // quote - not evaluate and return it.\n  \"`\": ({ node }) => {\n    return { ret: node[1] };\n  },\n\n  // eval - evaluate argument, and re-eval it.\n  eval: ({ node, flag }) => {\n    if (!flag) {\n      const cn = [...node];\n      return { ret: cn, reevals: [{ flag: \"!\" }], subevals: [{ parent: cn, index: 1 }] };\n    } else {\n      return { ret: node[1], reevals: [{ flag: null }] };\n    }\n  },\n\n  // def - define\n  def: ({ node, env, flag }) => {\n    if (!flag) {\n      const cn = [...node];\n      return { ret: cn, reevals: [{ flag: \"!\" }], subevals: [{ parent: cn, index: 2 }] };\n    } else {\n      const [, symbol, v = null] = node;\n      assertSymbol(symbol);\n      return { ret: setEnv(env, symbol, v) };\n    }\n  },\n\n  // defdynamic - define dynamic variable\n  defdynamic: ({ node, dynamicEnv, flag }) => {\n    if (!flag) {\n      const cn = [...node];\n      return { ret: cn, reevals: [{ flag: \"!\" }], subevals: [{ parent: cn, index: 2 }] };\n    } else {\n      const [, symbol, v = null] = node;\n      assertSymbol(symbol);\n      setEnv(getEnvRoot(dynamicEnv), symbol, v);\n      return { ret: v };\n    }\n  },\n\n  // ~ - define macro\n  \"~\": ({ node, flag }) => {\n    const cn = [...node];\n    if (!flag) {\n      return { ret: cn, reevals: [{ flag: \"!\" }], subevals: [{ parent: cn, index: 1 }] };\n    } else {\n      // Check if the evaluated value is applicable.\n      assertApplicable(cn[1]);\n      return { ret: cn };\n    }\n  },\n\n  // .- - get or set attribute/property, dereferencing BOR.\n  \".-\": ({ node, base, flag, interpreter }) => {\n    if (!flag) {\n      const cn = [...node];\n      return {\n        ret: cn,\n        reevals: [{ flag: \"!\" }],\n        subevals: cn.map((v, index) => index >= 1 && { parent: cn, index }),\n      };\n    } else {\n      const o = interpreter.derefBOR(node[1]) as any;\n      if (o === null || o === undefined) {\n        throw \"Can't read/set property of null or undefined.\";\n      }\n      const [, , prop, v] = node.map(a => interpreter.derefBOR(a));\n      assertPropertyIndex(prop);\n      return { ret: node.length === 3 ? o[prop] : o[prop] = v };\n    }\n  },\n\n  // . - call/apply method\n  \".\": ({ node, base, flag, interpreter }) => {\n    if (!flag) {\n      const cn = [...node];\n      return {\n        ret: cn,\n        reevals: [{ flag: \"!\" }],\n        subevals: cn.map((v, index) => index >= 1 && { parent: cn, index }),\n      };\n    } else {\n      const o = interpreter.derefBOR(node[1]) as any;\n      if (o === null || o === undefined) {\n        throw \"Can't call method of null or undefined.\";\n      }\n      const [, , prop, ...args] = node;\n      assertPropertyIndex(prop);\n      if (typeof o[prop] === \"function\") {\n        try {\n          return { ret: o[prop].apply(o, args.map(a => interpreter.wrapLambda(interpreter.derefBOR(a)))) };\n        } catch (e) {\n          if (isContinuation(e)) {\n            throw \"Javascript methods can not throw any continuation.\"\n          }\n          throw e;\n        }\n      } else {\n        assertApplicable(o[prop]);\n        return { ret: [o[prop], ...args], reevals: [{ flag: \"!\" }] };\n      }\n    }\n  },\n\n  // oget - get attribute/property, not dereferencing argument's BOR.\n  // Note: maybe JSLambda can do this.\n  oget: ({ node, base, flag, interpreter }) => {\n    if (!flag) {\n      const cn = [...node];\n      return {\n        ret: cn,\n        reevals: [{ flag: \"!\" }],\n        subevals: cn.map((v, index) => index >= 1 && { parent: cn, index }),\n      };\n    } else {\n      const o = interpreter.derefBOR(node[1]) as any;\n      if (o === null || o === undefined) {\n        throw \"Can't read property of null or undefined.\";\n      }\n      const [, , prop] = node;\n      assertPropertyIndex(prop);\n      return { ret: o[prop] };\n    }\n  },\n\n  // oset - set attribute/property, not dereferencing argument's BOR.\n  // Note: maybe JSLambda can do this.\n  oset: ({ node, base, flag, interpreter }) => {\n    if (!flag) {\n      const cn = [...node];\n      return {\n        ret: cn,\n        reevals: [{ flag: \"!\" }],\n        subevals: cn.map((v, index) => index >= 1 && { parent: cn, index }),\n      };\n    } else {\n      const o = interpreter.derefBOR(node[1]) as any;\n      if (o === null || o === undefined) {\n        throw \"Can't set property of null or undefined.\";\n      }\n      const [, , prop, v] = node;\n      assertPropertyIndex(prop);\n      return { ret: o[prop] = v };\n    }\n  },\n\n  // try-catch\n  // Note: catch clause's car does't have any meaning in minimal.\n  // Note: param is only one, not like `fn'.\n  try: ({ node, env, dynamicEnv, flag, cont, handler }) => {\n    assertTry(node);\n    if (!flag) {\n      const newErrorHandler: Eval = {\n        parent: cont.current.parent,\n        index: cont.current.index,\n        env: newEnv(env, [], []), // catch-clause runs on new env.\n        dynamicEnv,\n        flag: \"!!\", // Evaluate lambda.\n        handler, // Parent's error handler.\n      };\n      const cn = [...node];\n      // return evaluation requests for children nodes and reevaluation.\n      // Note: We must keep both body and catch-clause.\n      // Note: We'll set new error handler to re-evaluation request,\n      //       so that the request will be deleted when exception\n      //       is caught.\n      return {\n        ret: cn,\n        reevals: [{ flag: \"!\", handler: newErrorHandler }],\n        subevals: [{ parent: cn, index: 1, handler: newErrorHandler }]\n      };\n    } else if (flag === \"!\") {\n      // After body was evaluated, return value.\n      const [, body] = node;\n      return { ret: body };\n    } else if (flag === \"!!\") {\n      // Catch. run with new environment like function.\n      // Note: paremeter is already set in evalAST's catch clause.\n      const [, , [, , body]] = node;\n      return { ret: body, reevals: [{}] }\n    } else {\n      throw \"Illegal status for try-catch.\"\n    }\n  },\n\n  // fn - function (define lamda)\n  fn: ({ node, env }) => {\n    assertFn(node);\n    // defining lambda ( List lambda or JS lambda)\n    const [, params, body] = node;\n    return { ret: [\"=>\", params, body, env] };\n  },\n\n  // map - apply function/lambda to each items in a list\n  // Note: Maybe can be implimented by macro.\n  map: ({ node, flag }) => {\n    if (!flag) {\n      const cn = [...node];\n      return {\n        ret: cn,\n        reevals: [{ flag: \"!\" }],\n        subevals: cn.map((v, index) => index >= 1 && { parent: cn, index }),\n      };\n    } else {\n      const [, f, list] = node;\n      assertList(list);\n      const cl = list.map((_: any, i) => [f, list[i]]);\n      return {\n        ret: cl,\n        subevals: cl.map((v, index) => ({ parent: cl, index, flag: \"!\" })),\n      };\n    }\n  },\n\n  // apply - apply function/lambda with arguments.\n  apply: ({ node, flag }) => {\n    if (!flag) {\n      const cn = [...node];\n      return {\n        ret: cn,\n        reevals: [{ flag: \"!\" }],\n        subevals: cn.map((v, index) => index >= 1 && { parent: cn, index }),\n      };\n    } else {\n      const [, f, ...args] = node;\n      const last = args.pop();\n      assertList(last); // The last argument must be a list\n      args.push(...last); // concatenate the last to other args.\n      return {\n        ret: [f, ...args],\n        reevals: [{ flag: \"!\" }],\n      };\n    }\n  },\n\n  // let - new environment with bindings\n  // Translate to `do' form with new environment.\n  let: ({ node, env }) => {\n    assertLet(node);\n    const [, plist, body] = node;\n    if (plist.length % 2 === 1) {\n      plist.push(null);\n    }\n    const ppairs = plist.reduce<[Expr, Expr][]>(\n      (acc, v, i) => i % 2 ? acc : acc.concat([[plist[i], plist[i + 1]]]),\n      []\n    );\n    return {\n      ret: [\"do\", ...ppairs.map(([p, v]) => [\"def\", p, v]), body],\n      reevals: [{ env: newEnv(env, [], []) }],\n    }\n  },\n\n\n  // dynamic-let - new dynamic environment with bindings\n  \"dynamic-let\": ({ node, dynamicEnv, flag }) => {\n    assertDynamicLet(node);\n    if (!flag) {\n      const [f, plist, body] = node;\n      const cplist = [...plist];\n      return {\n        ret: [f, cplist, body],\n        subevals: cplist.map((v, i) => i).filter(i => (i % 2) === 1).map(i => ({parent: cplist, index: i})),\n        reevals: [{flag: \"!\"}],\n      };\n    } else {\n      const [, plist, body] = node;\n      if (plist.length % 2 === 1) {\n        plist.push(null);\n      }\n      const ppairs = plist.reduce<[Expr, Expr][]>(\n        (acc, v, i) => i % 2 ? acc : acc.concat([[plist[i], plist[i + 1]]]),\n        []\n      );\n      const nenv = newEnv(dynamicEnv, [],[]);\n      ppairs.forEach(([k, v]) => setEnv(nenv, String(k), v));\n      return {\n        ret: body,\n        reevals: [{ dynamicEnv: nenv }],\n      };\n    }\n  },\n\n  // do - multiple forms (for side-effects)\n  // Note: `do' MUST dispose the result of evalation except the last one.\n  // Note: last one substitutes the `do' form and re-evaluated not increasing stack.\n  do: ({ node }) => {\n    const [, ...args] = node;\n    const [last = null] = args.slice(-1); // Note: last becomes null if no args.\n    const rest = args.slice(0, -1);\n    return {\n      ret: last, // replace `do' from\n      reevals: [{ flag: null }],\n      subevals: rest.map(v => ({ parent: [v], index: 0 })), // Note: creating array means dispose results.\n    };\n  },\n\n  // if - branching conditional\n  if: ({ node, flag }) => {\n    if (!flag) {\n      const cn = [...node];\n      return { ret: cn, reevals: [{ flag: \"!\" }], subevals: [{ parent: cn, index: 1 }] };\n    } else {\n      return { ret: node[1] ? node[2] : node[3], reevals: [{ flag: null }] };\n    }\n  },\n\n  // suspend - throws continuation.\n  suspend: ({ node, flag, cont }) => {\n    if (!flag) {\n      const cn = [...node];\n      return { ret: cn, reevals: [{ flag: \"!\" }], subevals: [{ parent: cn, index: 1 }] };\n    } else {\n      const [, ...args] = node;\n      cont.info = args[0] ?? null;\n      throw cont;\n    }\n  },\n\n  // resume - resume the continuation.\n  // Note: Can be implemented by macro.\n  resume: ({ node, flag }) => {\n    const [, cont, ...args] = node;\n    assertContinuation(cont);\n    return { ret: [cont, ...args], reevals: [{ flag: \"!\" }] }\n  },\n  // Note: maybe we can implement a call/cc here.\n\n  // dynamic - Look up and get value of dynamic variable.\n  dynamic: ({ node, dynamicEnv }) => {\n    const [, name] = node;\n    assertSymbol(name);\n    const [v, found] = findEnv(dynamicEnv, null, name);\n    return { ret: found ? v : error(`dynamic variable ${name} not found`) };\n  }\n\n};\n\n// -------------------------------------------------------\n//                Environment wrapper\n// -------------------------------------------------------\n\n// This class wraps environment (with base object) and provides get/has/set method.\n// Used for passing environment information to JS lambdas.\nexport class EnvWrapper {\n  private env: Env;\n  private dynamicEnv: Env;\n  private base: Base;\n  constructor(env: Env, dynamicEnv: Env, base: Base) {\n    this.env = env;\n    this.dynamicEnv = dynamicEnv;\n    this.base = base;\n  }\n  get = (name: string) => findEnv(this.env, this.base, name)[0];\n  has = (name: string) => findEnv(this.env, this.base, name)[1];\n  set = (name: string, value: Expr) => setEnv(this.env, name, value);\n  dynamicGet = (name: string) => findEnv(this.dynamicEnv, this.base, name)[0];\n  dynamicHas = (name: string) => findEnv(this.dynamicEnv, this.base, name)[1];\n  dynamicSet = (name: string, value: Expr) => setEnv(getEnvRoot(this.dynamicEnv), name, value);\n  dynamicSetLocal = (name: string, value: Expr) => setEnv(this.dynamicEnv, name, value);\n}\n\n// -------------------------------------------------------\n//                    Default base\n// -------------------------------------------------------\n\n// eslint-disable-next-line\nexport const TheGlobal = globalThis || window || global || this;\n\nconst DEFAULT_BASE: Base = Object.assign(Object.create(TheGlobal), {\n  \"=\": (...a: Expr[]) => a[0] === a[1],\n  \"<\": (...a: Expr[]) => Number(a[0]) < Number(a[1]),\n  \"+\": (...a: Expr[]) => Number(a[0]) + Number(a[1]),\n  \"-\": (...a: Expr[]) => Number(a[0]) - Number(a[1]),\n  \"*\": (...a: Expr[]) => Number(a[0]) * Number(a[1]),\n  \"/\": (...a: Expr[]) => Number(a[0]) / Number(a[1]),\n  isa: (...a: Expr[]) => a[0] instanceof (a[1] as any),\n  type: (...a: Expr[]) => typeof a[0],\n  new: (...a: Expr[]) => new ((a[0] as any).bind(...a))(),\n  del: (...a: Expr[]) => delete (a[0] as any)[a[1] as any],\n  //\"list\":  (...a) => a,\n  //\"map\":   (...a) => a[1].map(x => a[0](x)),\n  throw: (...a: Expr[]) => {\n    throw a[0];\n  },\n\n  read: (...a: Expr[]) => JSON.parse(a[0] as any),\n\n  // eslint-disable-next-line no-eval\n  js: eval,\n  //\"slurp\": (...a) => require(\"fs\").readFileSync(a[0],\"utf8\"),\n  //\"load\":  (...a) => EVAL(JSON.parse(require(\"fs\").readFileSync(a[0],\"utf8\")),E),\n});\n\nexport default Interpreter;\n","export * from \"./interpreter\";\r\n"]}